Hillary Clinton regained control of the Democratic race on Saturday. But as a new portrait of a Bernie Sanders voter emerges, she’ll be challenged to keep that control through what could be a very long contest.Clinton backers can take solace in halting the wave of momentum Sanders rode into Nevada and its caucuses. She weathered an influx of liberals and first-time caucus-goers to win in an unpredictable state.Yet there’s a flip side. In the most diverse state to vote so far, Sanders pieced together a coalition that draws on both demography and ideology to show he can and likely will challenge Clinton for months to come.Clinton does have wins in two of the first three states, with a favorable map – starting with next weekend’s contest in South Carolina – ahead of her. There’s no big delegate bounty yet; in Nevada, as in Iowa, the math delivers her only a slight edge, with plenty of contests to come that can shift the balance.Hillary Clinton Projected to Win Nevada CaucusesLive Nevada Democratic Caucus Entrance Poll AnalysisCritically, Sanders showed in Nevada that his campaign can reach a different swath of voters. Sanders carried Latino voters by eight percentage points, even though Clinton won two-thirds of Hispanics in the same state eight years ago. Though Sanders lost African-Americans by a 3-1 margin, he’s at least shown that he can win voters who aren’t white.Sanders again trounced Clinton among younger voters. Three-fourths of caucus-goers under age 45 supported Sanders on Saturday, and he won nearly 85 percent of those under 30.Despite the loss, Sanders has a clear claim on the hearts of Democrats. For voters wanting a candidate who “cares about people like me,” eight in 10 chose Sanders. Among those wanting a candidate who is “honest and trustworthy,” Sanders got 85 percent.Clinton retains a hold on the party’s heads. For voters who value electability in November, more than three-fourths favored Clinton in Nevada. For those wanting the “right experience,” the margin was even more lopsided – north of 90 percent.Clinton backers have made much of her “firewall” – the cache of states that vote between next weekend and early March that have large numbers of black and working-class white voters. That’s the Clinton base, and she’s better positioned coming out of Nevada to start a winning streak that will quiet the loudest of critics.Sanders will need to win some states he’s not expected to if he’s going to contend for the nomination. That didn’t happen in Nevada. The Democratic race, though, very clearly will have two contenders for a good while.

Early computers were built to perform a series of single tasks, like a calculator. Basic operating system features were developed in the 1950s, such as resident monitor functions that could automatically run different programs in succession to speed up processing. Operating systems did not exist in their modern and more complex forms until the early 1960s.[6] Hardware features were added, that enabled use of runtime libraries, interrupts, andparallel processing. When personal computers became popular in the 1980s, operating systems were made for them similar in concept to those used on larger computers.
In the 1940s, the earliest electronic digital systems had no operating systems. Electronic systems of this time were programmed on rows of mechanical switches or by jumper wires on plug boards. These were special-purpose systems that, for example, generated ballistics tables for the military or controlled the printing of payroll checks from data on punched paper cards. After programmable general purpose computers were invented, machine languages (consisting of strings of the binary digits 0 and 1 on punched paper tape) were introduced that sped up the programming process (Stern, 1981)In the early 1950s, a computer could execute only one program at a time. Each user had sole use of the computer for a limited period of time and would arrive at a scheduled time with program and data on punched paper cards or punched tape. The program would be loaded into the machine, and the machine would be set to work until the program completed or crashed. Programs could generally be debugged via a front panel using toggle switches and panel lights. It is said that Alan Turing was a master of this on the early Manchester Mark 1 machine, and he was already deriving the primitive conception of an operating system from the principles of the Universal Turing machine. 